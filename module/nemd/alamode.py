# This software is licensed under the BSD 3-Clause License.
# Authors: Teng Zhang (zhteg4@gmail.com)
"""
ALAMODE utilities.

https://github.com/ttadano/alamode
"""
import functools
import itertools
import os

import pandas as pd

from nemd import builtinsutils
from nemd import constants
from nemd import lmpatomic
from nemd import lmpin
from nemd import osutils
from nemd import process
from nemd import symbols
from nemd import table
from nemd import xtal

INDENT = "  "
SUGGEST = symbols.SUGGEST
OPTIMIZE = symbols.OPTIMIZE
PHONONS = symbols.PHONONS


class Script(lmpin.Script):
    """
    Customized to dump force.
    """
    CUSTOM_EXT = lmpin.SinglePoint.CUSTOM_EXT

    def dump(self, *args, force=True, **kwargs):
        """
        See parent.
        """
        super().dump(*args, force=force, **kwargs)

    def dump_modify(self, *args, sort=False, fmt="float '%20.15f'", **kwargs):
        """
        See parent.
        """
        super().dump_modify(*args, sort=sort, fmt=fmt, **kwargs)


class Struct(lmpatomic.Struct):
    """
    Customized with input script.
    """

    @functools.cached_property
    def script(self):
        """
        See parent.
        """
        return Script(struct=self)


class Lmp(process.Lmp):
    """
    Customized with force dump as the output.
    """

    def __init__(self, struct, **kwargs):
        """
        :param struct Struct: the structure to get in script and data file from.
        """
        super().__init__(infile=struct.script.outfile, **kwargs)
        self.struct = struct
        if not self._files:
            return
        basename = os.path.splitext(os.path.basename(self._files[0]))[0]
        self.dirname = f"lammps{basename.removeprefix(self.jobname)}"

    def setUp(self):
        """
        See parent.
        """
        self.struct.script.write()
        if self.files:
            osutils.symlink(self.files[0], self.struct.outfile)
        else:
            self.struct.write()

    @property
    def ext(self):
        """
        See parent.
        """
        return Script.CUSTOM_EXT


def exe(obj, **kwargs):
    """
    Run the executables and return output files.

    :param obj str, Crystal, or Struct: based on which the Runner is chosen
    :return list: the output files.
    :raise ValueError: if the obj is unknown.
    """
    if hasattr(obj, 'options'):
        kwargs.setdefault('jobname', obj.options.JOBNAME)
    if isinstance(obj, lmpatomic.Struct):
        Runner = Lmp
    elif isinstance(obj, Crystal):
        Runner = process.Alamode
    elif obj in [process.Tools.DISPLACE, process.Tools.EXTRACT]:
        Runner = process.Tools
    else:
        raise ValueError(f"Unknown {obj}.")
    runner = Runner(obj, **kwargs)
    runner.run()
    return runner.outfiles


class Crystal(xtal.Crystal, builtinsutils.Object):
    """
    Customized to generate alamode input script.
    """

    def __init__(self, *args, mode=SUGGEST, **kwargs):
        """
        :param mode str: the mode of the calculation.
        """
        super().__init__(*args, **kwargs)
        self.mode = mode
        self.outfile = f"{self.options.JOBNAME if self.options else self.name}.in"

    def write(self):
        """
        Write out the alamode input script.
        """
        with open(self.outfile, 'w') as fh:
            General(self).write(fh)
            Optimize(self).write(fh)
            Interaction(self).write(fh)
            Cutoff(self).write(fh)
            Cell.fromCrystal(self).write(fh)
            Position.fromCrystal(self).write(fh)
            Kpoint.fromCrystal(self).write(fh)


class General(builtinsutils.Dict):
    """
    The &general-filed.
    """

    def __init__(self, crystal):
        """
        :param crystal Crystal: the crystal structure
        """
        super().__init__()
        self.setattr('crystal', crystal)
        self.setUp()

    def setUp(self, modes=(SUGGEST, OPTIMIZE)):
        """
        Set up.

        :param modes tuple: the modes that have a difference setup.
        """
        self.PREFIX = self.crystal.options.JOBNAME
        self.MODE = self.crystal.mode
        species = self.crystal.chemical_composition.keys()
        self.NKD = len(species)  # Atom specie number
        self.KD = species  # The atom specie names
        if self.crystal.mode in modes:
            # The total atoms in the supercell
            self.NAT = len(self.crystal.supercell.atoms)
            return
        # The masses of the specie
        self.MASS = [table.TABLE.loc[x].atomic_weight for x in species]
        # File containing force constants generated by the program alm
        self.FCSXML = f"{self.crystal.options.JOBNAME}{symbols.XML_EXT}"

    def write(self, fh, sep=' = '):
        """
        Write the key value pairs to the file handle.

        :param fh '_io.TextIOWrapper': the file handle to write to.
        :param sep str: the seperator between key and value
        """
        if not self:
            return
        fh.write(f"{symbols.AND}{self.__class__.__name__.lower()}\n")
        for key, val in self.items():
            fh.write(f"{INDENT}{key}{sep}{self.format(val)}\n")
        fh.write(f"{symbols.FORWARDSLASH}\n\n")

    @staticmethod
    def format(val):
        """
        Format the value to be written out.

        :param val any: the value to be written out.
        :return str: the formatted value.
        """
        if hasattr(val, '__iter__') and not isinstance(val, str):
            return symbols.SPACE.join(map(str, val))
        return val


class Optimize(General):
    """
    The &optimize-filed.
    """

    def setUp(self, mode=OPTIMIZE):
        """
        See parent.
        """
        if self.crystal.mode == OPTIMIZE:
            # The displacement-force data set
            self.DFSET = f"{self.crystal.options.JOBNAME}{symbols.DFSET_EXT}"


class Interaction(General):
    """
    The &interaction-filed.
    """

    def setUp(self, modes=(SUGGEST, OPTIMIZE)):
        """
        See parent.
        """
        if self.crystal.mode in modes:
            # The order of force constant: 1) harmonic; 2) cubic; ..
            self.NORDER = 1


class Cutoff(General):
    """
    The &cutoff-field.
    """

    def setUp(self, modes=(SUGGEST, OPTIMIZE)):
        """
        See parent.
        """
        if self.crystal.mode in modes:
            species = self.crystal.chemical_composition.keys()
            pairs = itertools.combinations_with_replacement(species, 2)
            self.update({f"{x}-{y}": 7.3 for x, y in pairs})

    def write(self, *args, sep=symbols.SPACE, **kwargs):
        """
        See parent.
        """
        super().write(*args, sep=sep, **kwargs)


class Cell(pd.DataFrame):
    """
    The &cell-field.
    """

    def write(self, fh, header=False, float_format='%0.8f', index=False):
        """
        Write the data to the file handle.

        :param fh '_io.TextIOWrapper': the file handler to write to.
        :param header bool: whether the header is written out.
        :param float_format str: the format of the float values.
        :param index bool: whether the index is written out.
        """
        if self.empty:
            return
        fh.write(f"{symbols.AND}{self.__class__.__name__.lower()}\n")
        if self.index.name is not None:
            fh.write(f"{INDENT}{self.index.name}\n")
        lines = self.to_string(header=header,
                               float_format=float_format,
                               index=index)
        for line in lines.split('\n'):
            fh.write(f"{INDENT}{line}\n")
        fh.write(f"{symbols.FORWARDSLASH}\n\n")

    @classmethod
    def fromCrystal(cls, crystal):
        """
        The cell parameters.

        :return 'Cell': cell vectors (with a scale factor).
        """
        vecs = crystal.primitive().lattice_vectors if crystal.mode == PHONONS \
            else crystal.supercell.scaled_lattice_vectors
        vecs = [x * constants.ANG_TO_BOHR for x in vecs]
        data = cls(vecs)
        data.index.name = 1  # scale factor
        return data


class Position(Cell):
    """
    The &position-field.
    """

    @classmethod
    def fromCrystal(cls, crystal, modes=(SUGGEST, OPTIMIZE)):
        """
        See parent.
        """
        if crystal.mode not in modes:
            return cls()
        cell = crystal.supercell
        data = [x.coords_fractional / cell.dimensions for x in cell.atoms]
        index = [x.element for x in cell.atoms]
        data = cls(data, index=index)
        data.sort_values(by=list(data.columns), inplace=True)
        species = crystal.chemical_composition.keys()
        id_map = {x: i for i, x in enumerate(species, start=1)}
        data.rename(index=id_map, inplace=True)
        data.reset_index(inplace=True)
        return data


class Kpoint(Cell):
    """
    The &kpoint-field
    """
    # https://en.wikipedia.org/wiki/Brillouin_zone
    # https://www.businessballs.com/glossaries-and-terminology/greek-alphabet/
    # Center of the Brillouin zone
    GAMMA = pd.Series([0, 0, 0], name='G')
    # Simple cube
    CHI = pd.Series([0.5, 0.5, 0.0], name='X')  # Center of a square face
    RHO = pd.Series([0.5, 0.5, 1], name='R')  # Corner point
    LAMBDA = pd.Series([0.5, 0.5, 0.5], name='L')  # Center of a hexagonal face
    GRID = 51

    @classmethod
    def fromCrystal(cls, crystal, mode=PHONONS):
        """
        See parent.
        """
        if crystal.mode != mode:
            return cls()
        lines = [[cls.GAMMA, cls.CHI], [cls.RHO, cls.GAMMA, cls.LAMBDA]]
        pairs = [[y, z] for x in lines for y, z in zip(x[:-1], x[1:])]
        start = pd.DataFrame([x[0] for x in pairs]).reset_index()
        end = pd.DataFrame([x[1] for x in pairs]).reset_index()
        data = pd.concat([start, end], axis=1)
        data.insert(len(data.columns), 'grid', cls.GRID)
        data.index.name = 1  # line mode
        return cls(data)
